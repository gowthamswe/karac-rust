# Chapter 5: Parsing and the Abstract Syntax Tree (AST)

This chapter delves into the first major stage of the K훮ra compiler: parsing the source code and constructing an Abstract Syntax Tree (AST). The AST is a tree representation of the source code that is easier for the compiler to work with.

---

## 1. The Parser's Role

The parser takes the stream of tokens generated by the lexer and organizes them into a hierarchical structure that reflects the grammar of the K훮ra language. This structure is the AST.

The AST for K훮ra will be defined in a new crate, `kara-ast`. This will allow the AST to be shared between the parser and other parts of the compiler, such as the semantic analyzer and the code generator.

## 2. Defining the AST

The AST will be a collection of Rust structs and enums that represent the different parts of a K훮ra program. Here is a preliminary design for the AST:

```rust
// In `kara-ast/src/lib.rs`

pub struct File {
    pub items: Vec<TopLevelItem>,
}

pub enum TopLevelItem {
    Record(RecordDefinition),
    Type(TypeDefinition),
    Flow(FlowDefinition),
    Fn(FnDefinition),
}

pub struct RecordDefinition {
    pub name: String,
    pub fields: Vec<FieldDefinition>,
}

pub struct FieldDefinition {
    pub name: String,
    pub type_name: String,
}

pub struct TypeDefinition {
    pub name: String,
    pub underlying_type: String,
}

pub struct FlowDefinition {
    pub name: String,
    pub params: Vec<Parameter>,
    pub body: Vec<Statement>,
}

pub struct FnDefinition {
    pub name: String,
    pub params: Vec<Parameter>,
    pub return_type: Option<Vec<Parameter>>,
    pub body: Vec<Statement>,
}

pub struct Parameter {
    pub name: String,
    pub type_name: String,
}

pub enum Statement {
    Let(LetBinding),
    Pipeline(Pipeline),
}

pub struct LetBinding {
    pub name: String,
    pub expr: Expression,
}

pub struct Pipeline {
    pub expressions: Vec<Expression>,
}

pub enum Expression {
    Identifier(String),
    Literal(Literal),
}

pub enum Literal {
    String(String),
    Integer(i64),
    Float(f64),
    Boolean(bool),
}
```

This AST structure directly mirrors the EBNF grammar defined in Chapter 2. The parser will be responsible for creating these data structures from the token stream.
